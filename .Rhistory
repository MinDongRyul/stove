mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels,
metric = metric
)
## models_list에 모델을 추가합니다.
models_list[[paste0(algo,"_",engine)]] <- finalized$finalFittedModel
## User input
mode <- "classification"
algo <- "KNN"
engine <- "kknn"
neighborsRangeMin = "2"
neighborsRangeMax = "8"
neighborsRangeLevels = "4"
v <- "2"
metric <- "roc_auc"
## grid search + cross validation + modeling
finalized <- goophi::KNN(algo = algo,
engine = engine,
mode = mode,
trainingData = data_train,
splitedData = data_split,
formula = formula,
rec = rec,
v = v,
neighborsRangeMin = neighborsRangeMin,
neighborsRangeMax = neighborsRangeMax,
neighborsRangeLevels = neighborsRangeLevels,
metric = metric
)
## models_list에 모델을 추가합니다.
models_list[[paste0(algo,"_",engine)]] <- finalized$finalFittedModel
## User input
mode <- "classification"
algo <- "MLP"
engine <- "nnet"
hiddenUnitsRangeMin = "1"
hiddenUnitsRangeMax = "10"
hiddenUnitsRangeLevels = "3"
penaltyRangeMin = "0.01"
penaltyRangeMax = "0.5"
penaltyRangeLevels = "3"
epochsRangeMin = "10"
epochsRangeMax = "100"
epochsRangeLevels = "2"
# dropoutRangeMin = "0"
# dropoutRangeMax = "1"
# dropoutRangeLevels = "2"
# activation = "relu" #"linear", "softmax", "relu", "elu"
# learnRateRangeMin = "0"
# learnRateRangeMax = "1"
# learnRateRangeLevels = "2"
v <- "2"
metric <- "roc_auc"
## grid search + cross validation + modeling
finalized <- goophi::MLP(algo = algo,
engine = engine,
mode = mode,
trainingData = data_train,
splitedData = data_split,
formula = formula,
rec = rec,
v = v,
hiddenUnitsRangeMin = hiddenUnitsRangeMin,
hiddenUnitsRangeMax = hiddenUnitsRangeMax,
hiddenUnitsRangeLevels = hiddenUnitsRangeLevels,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
epochsRangeMin = epochsRangeMin,
epochsRangeMax = epochsRangeMax,
epochsRangeLevels = epochsRangeLevels,
# dropoutRangeMin = dropoutRangeMin,
# dropoutRangeMax = dropoutRangeMax,
# dropoutRangeLevels = dropoutRangeLevels,
# activation = activation, #"linear", "softmax", "relu", "elu"
# learnRateRangeMin = learnRateRangeMin,
# learnRateRangeMax = learnRateRangeMax,
# learnRateRangeLevels = learnRateRangeLevels,
metric = metric
)
## models_list에 모델을 추가합니다.
models_list[[paste0(algo,"_",engine)]] <- finalized$finalFittedModel
#######################################
## User input
mode <- "classification"
algo <- "Decision Tree"
engine <- "rpart"
treeDepthRangeMin = "3"
treeDepthRangeMax = "10"
treeDepthRangeLevels = "3"
minNRangeMin = "10"
minNRangeMax = "50"
minNRangeLevels = "3"
costComplexityRangeMin = "-1"
costComplexityRangeMax = "5"
costComplexityRangeLevels = "3"
v <- "2"
metric <- "roc_auc"
## grid search + cross validation + modeling
finalized <- goophi::decisionTree(algo = algo,
engine = engine,
mode = mode,
trainingData = data_train,
splitedData = data_split,
formula = formula,
rec = rec,
v = 2,
treeDepthRangeMin = treeDepthRangeMin,
treeDepthRangeMax = treeDepthRangeMax,
treeDepthRangeLevels = treeDepthRangeLevels,
minNRangeMin = minNRangeMin,
minNRangeMax = minNRangeMax,
minNRangeLevels = minNRangeLevels,
costComplexityRangeMin = costComplexityRangeMin,
costComplexityRangeMax = costComplexityRangeMax,
costComplexityRangeLevels = costComplexityRangeLevels,
metric = metric
)
## models_list에 모델을 추가합니다.
models_list[[paste0(algo,"_",engine)]] <- finalized$finalFittedModel
## A correlation computation is required, but `estimate` is constant and has 0 standard deviation ... warning은
## User input
mode <- "classification"
algo <- "Random Forest"
engine <- "ranger"
mtryRangeMin <- "1"
mtryRangeMax <- "5"
mtryRangeLevels <- "3"
treesRangeMin <- "500"
treesRangeMax <- "2000"
treesRangeLevels <- "3"
minNRangeMin <- "1"
minNRangeMax <- "10"
minNRangeLevels <- "3"
v <- "2"
metric <- "roc_auc"
## grid search + cross validation + modeling
finalized <- goophi::randomForest(algo = algo,
engine = engine,
mode = mode,
trainingData = data_train,
splitedData = data_split,
formula = formula,
rec = rec,
v = 2,
mtryRangeMin = mtryRangeMin,
mtryRangeMax = mtryRangeMax,
mtryRangeLevels = mtryRangeLevels,
treesRangeMin = treesRangeMin,
treesRangeMax = treesRangeMax,
treesRangeLevels = treesRangeLevels,
minNRangeMin = minNRangeMin,
minNRangeMax = minNRangeMax,
minNRangeLevels = minNRangeLevels,
metric = metric
)
## models_list에 모델을 추가합니다.
models_list[[paste0(algo,"_",engine)]] <- finalized$finalFittedModel
## User input
mode <- "classification"
algo <- "XGBoost"
engine <- "xgboost"
treeDepthRangeMin <- "3"
treeDepthRangeMax <- "6"
treeDepthRangeLevels <- "2"
treesRangeMin <- "10"
treesRangeMax <- "15"
treesRangeLevels <- "2"
learnRateRangeMin <- "0.01"
learnRateRangeMax <- "0.3"
learnRateRangeLevels <- "2"
mtryRangeMin <- "1"
mtryRangeMax <- "9"
mtryRangeLevels <- "3"
minNRangeMin <- "1"
minNRangeMax <- "10"
minNRangeLevels <- "3"
lossReductionRangeMin <- "0"
lossReductionRangeMax <- "10"
lossReductionRangeLevels <- "2"
sampleSizeRangeMin <- "0"
sampleSizeRangeMax <- "1"
sampleSizeRangeLevels <- "2"
stopIter <- "10"
v <- "2"
metric <- "roc_auc"
## grid search + cross validation + modeling
finalized <- goophi::xgboost(algo = algo,
engine = engine,
mode = mode,
trainingData = data_train,
splitedData = data_split,
formula = formula,
rec = rec,
v = 2,
treeDepthRangeMin = treeDepthRangeMin,
treeDepthRangeMax = treeDepthRangeMax,
treeDepthRangeLevels = treeDepthRangeLevels,
treesRangeMin = treesRangeMin,
treesRangeMax = treesRangeMax,
treesRangeLevels = treesRangeLevels,
learnRateRangeMin = learnRateRangeMin,
learnRateRangeMax = learnRateRangeMax,
learnRateRangeLevels = learnRateRangeLevels,
mtryRangeMin = mtryRangeMin,
mtryRangeMax = mtryRangeMax,
mtryRangeLevels = mtryRangeLevels,
minNRangeMin = minNRangeMin,
minNRangeMax = minNRangeMax,
minNRangeLevels = minNRangeLevels,
lossReductionRangeMin = lossReductionRangeMin,
lossReductionRangeMax = lossReductionRangeMax,
lossReductionRangeLevels = lossReductionRangeLevels,
sampleSizeRangeMin = sampleSizeRangeMin,
sampleSizeRangeMax = sampleSizeRangeMax,
sampleSizeRangeLevels = sampleSizeRangeLevels,
stopIter = stopIter,
metric = metric
)
## models_list에 모델을 추가합니다.
models_list[[paste0(algo,"_",engine)]] <- finalized$finalFittedModel
## User input
mode <- "classification"
algo <- "light GBM"
engine <- "lightgbm"
treeDepthRangeMin <- "3"
treeDepthRangeMax <- "6"
treeDepthRangeLevels <- "2"
treesRangeMin <- "10"
treesRangeMax <- "15"
treesRangeLevels <- "2"
learnRateRangeMin <- "0.01"
learnRateRangeMax <- "0.3"
learnRateRangeLevels <- "2"
mtryRangeMin <- "1"
mtryRangeMax <- "9"
mtryRangeLevels <- "3"
minNRangeMin <- "1"
minNRangeMax <- "10"
minNRangeLevels <- "3"
lossReductionRangeMin <- "0"
lossReductionRangeMax <- "10"
lossReductionRangeLevels <- "2"
v <- "2"
metric <- "roc_auc"
## grid search + cross validation + modeling
finalized <- goophi::lightGbm(algo = algo,
engine = engine,
mode = mode,
trainingData = data_train,
splitedData = data_split,
formula = formula,
rec = rec,
v = 2,
treeDepthRangeMin = treeDepthRangeMin,
treeDepthRangeMax = treeDepthRangeMax,
treeDepthRangeLevels = treeDepthRangeLevels,
treesRangeMin = treesRangeMin,
treesRangeMax = treesRangeMax,
treesRangeLevels = treesRangeLevels,
learnRateRangeMin = learnRateRangeMin,
learnRateRangeMax = learnRateRangeMax,
learnRateRangeLevels = learnRateRangeLevels,
mtryRangeMin = mtryRangeMin,
mtryRangeMax = mtryRangeMax,
mtryRangeLevels = mtryRangeLevels,
minNRangeMin = minNRangeMin,
minNRangeMax = minNRangeMax,
minNRangeLevels = minNRangeLevels,
lossReductionRangeMin = lossReductionRangeMin,
lossReductionRangeMax = lossReductionRangeMax,
lossReductionRangeLevels = lossReductionRangeLevels,
metric = metric
)
## models_list에 모델을 추가합니다.
models_list[[paste0(algo,"_",engine)]] <- finalized$finalFittedModel
roc_curve <- goophi::rocCurve(modelsList = models_list,
targetVar = targetVar)
?ggplot2::theme_cowplot
?theme_cowplot
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
roc_curve <- goophi::rocCurve(modelsList = models_list,
targetVar = targetVar)
roc_curve
model_name = "Random Forest_ranger" # 원하는 모델의 이름 입력받기
cm <- goophi::confusionMatrix(modelName = model_name,
modelsList = models_list,
targetVar = targetVar)
cm
evalMet <- goophi::evalMetricsC(models_list, targetVar)
models_list
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
evalMet <- goophi::evalMetricsC(models_list, targetVar)
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
evalMet <- goophi::evalMetricsC(models_list, targetVar)
knitr::kable(evalMet)
library(goophi)
url = 'http://www.biz.uiowa.edu/faculty/jledolter/DataMining/protein.csv'
mydata <- readr::read_csv(url)
data_cleaned <- mydata %>% dplyr::select(RedMeat, WhiteMeat, Eggs, Milk) ## unsupervised -> target 변수는 제외
## 여기까지 완료된 데이터가 전달된다고 가정 (one-hot encoding까지 되는지 확인 필요) ##
# user로부터 아래 정보를 입력받습니다
maxK <- 15 # k = 2:maxK
selectOptimal <- "silhouette" # "silhouette", "gap_stat" // there's no mathematical definition for selecting optimal k using elbow method.
nstart <- 25 # attempts 25 initial configurations
# K-means clustering 모델을 생성합니다.
km_model <- goophi::kMeansClustering(data_cleaned,
maxK = 10,
nstart = 25,
selectOptimal = "gap_stat",
seed_num = 6471)
km_model
fviz_gap_stat(gap_stat)
# /vignettes 폴더에 패키지 설명서 추가
usethis::use_vignette("clusteringWorkflow")
require(dplyr) # import for loading/preprocessing the sample data
library(goophi)
require(dplyr) # import for loading/preprocessing the sample data
library(goophi)
library(goophi)
url = 'http://www.biz.uiowa.edu/faculty/jledolter/DataMining/protein.csv'
mydata <- readr::read_csv(url)
data_cleaned <- mydata %>% dplyr::select(RedMeat, WhiteMeat, Eggs, Milk) ## unsupervised -> target 변수는 제외
# user로부터 아래 정보를 입력받습니다
maxK <- 15 # k = 2:maxK
selectOptimal <- "silhouette" # "silhouette", "gap_stat" // there's no mathematical definition for selecting optimal k using 'elbow' method.
nstart <- 25 # attempts 25 initial configurations
# K-means clustering 모델을 생성합니다.
km_model <- goophi::kMeansClustering(data_cleaned,
maxK = 10,
nstart = 25,
selectOptimal = "gap_stat",
seed_num = 6471)
km_model
?clusGap
library(cluster)
set.seed(123)
set.seed(123)
# Compute gap statistic for kmeans
# we used B = 10 for demo. Recommended value is ~500
gap_stat <- cluster::clusGap(data_cleaned, FUN = kmeans, nstart = 25,
K.max = 10, B = 10)
print(gap_stat, method = "firstmax")
fviz_gap_stat(gap_stat)
gap_stat <- clusGap(data_cleaned, FUN = hcut, K.max = 10, B = 10)
fviz_gap_stat(gap_stat)
library(cluster)
set.seed(123)
# Compute gap statistic for kmeans
# we used B = 10 for demo. Recommended value is ~500
gap_stat <- cluster::clusGap(data_cleaned, FUN = kmeans, nstart = 25,
K.max = 10, B = 10)
print(gap_stat, method = "firstmax")
fviz_gap_stat(gap_stat)
# Gap statistic for hierarchical clustering
gap_stat <- clusGap(data_cleaned, FUN = hcut, K.max = 10, B = 10)
fviz_gap_stat(gap_stat)
library(cluster)
set.seed(123)
# Compute gap statistic for kmeans
# we used B = 10 for demo. Recommended value is ~500
gap_stat <- cluster::clusGap(data_cleaned, FUN = kmeans, nstart = 25,
K.max = 10, B = 500)
fviz_gap_stat(gap_stat)
?fviz_gap_stat
?kmeans
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
## user input
maxK <- 15 # k = 2:maxK
selectOptimal <- "silhouette" # "silhouette", "gap_stat" // there's no mathematical definition for selecting optimal k using 'elbow' method.
nStart <- 25 # attempts 25 initial configurations
## K-means clustering
km_model <- goophi::kMeansClustering(data = data_cleaned,
maxK = maxK,
nstart = nStart,
selectOptimal = selectOptimal,
seed_num = 6471)
km_model
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
## user input
maxK <- 15 # k = 2:maxK
selectOptimal <- "silhouette" # "silhouette", "gap_stat" // there's no mathematical definition for selecting optimal k using 'elbow' method.
nStart <- 25 # attempts 25 initial configurations
## K-means clustering
km_model <- goophi::kMeansClustering(data = data_cleaned,
maxK = maxK,
nstart = nStart,
selectOptimal = selectOptimal,
seed_num = 6471)
km_model
optimalK <- goophi::optimalK(data = data_cleaned,
nStart = nStart,
kMax = maxK,
b = 100)
optimalK <- goophi::optimalK(data = data_cleaned,
nStart = nStart,
maxK = maxK,
b = 100)
optimalK
optimalK <- goophi::optimalK(data = data_cleaned,
nStart = nStart,
maxK = maxK,
b = 500)
optimalK
fviz_cluster(km_model, data = data_cleaned,
palette = c("#2E9FDF", "#00AFBB", "#E7B800"),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
km_model$?fviz_cluster
?fviz_cluster
# optimalK <- goophi::optimalK(data = data_cleaned,
#                      nStart = nStart,
#                      maxK = maxK,
#                      b = 500)
# optimalK
fviz_nbclust(data_cleaned, stats::kmeans, method = "silhouette")
km_model$cluster
km_model$centers
km_model$totss
## user input
maxK <- 15 # k = 2:maxK
selectOptimal <- "silhouette" # "silhouette", "gap_stat" // there's no mathematical definition for selecting optimal k using 'elbow' method.
nStart <- 25 # attempts 25 initial configurations
seed = 1234
## K-means clustering
km_model <- goophi::kMeansClustering(data = data_cleaned,
maxK = maxK,
nstart = nStart,
selectOptimal = selectOptimal,
seed_num = seed)
km_model
?theme_bw
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
library(goophi)
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
library(goophi)
vis_result <- goophi::clusteringVis(data = data_cleaned,
model = km_model,
nStart = 25,
maxK = 10)
optimalK <- fviz_nbclust(data_cleaned, stats::kmeans, method = "silhouette")
optimalK
clustVis <- factoextra::fviz_cluster(model = km_model,
data = data_cleaned,
palette = c("#2E9FDF", "#00AFBB", "#E7B800"),
geom = "point",
ellipse.type = "convex",
ggtheme = ggplot2::theme_bw()
)
factoextra::fviz_cluster(model = km_model,
data = data_cleaned,
palette = c("#2E9FDF", "#00AFBB", "#E7B800"),
geom = "point",
ellipse.type = "convex",
ggtheme = ggplot2::theme_bw()
)
?factoextra::fviz_cluster
clustVis <- factoextra::fviz_cluster(object = km_model,
data = data_cleaned,
palette = c("#2E9FDF", "#00AFBB", "#E7B800"),
geom = "point",
ellipse.type = "convex",
ggtheme = ggplot2::theme_bw()
)
clustVis
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
vis_result <- goophi::clusteringVis(data = data_cleaned,
model = km_model,
nStart = 25,
maxK = 10)
vis_result
vis_result$clustVis
vis_result$optimalK
vis_result <- goophi::clusteringVis(data = data_cleaned,
model = km_model,
nStart = 25,
maxK = 10)
vis_result$clustVis
vis_result$optimalK
### User input
?all_nominal_predictors
```{r}
targetVar <- "SalePrice"
trainSetRatio <- "0.7"
```
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
library(goophi)
require(dplyr) # import for loading/preprocessing the sample data
require(MASS)
data("Boston")
attach(Boston)
library(goophi)
options(yardstick.event_first = FALSE) # 오름차순으로 factor의 level 설정된다고 가정
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
