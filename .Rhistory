v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
data_train
model_result
model_result$result
model_result$result$.metrics
model_result$tunedWorkflow
model_result$result$splits
model_result$result$.metrics
require(dplyr)
library(goophi)
grid_search_result <- goophi::logisticRegression_phi(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
finalized <- goophi::fitBestModel(gridSearchResult = grid_search_result,
metric = metric,
model = model,
formula = formula,
trainingData = data_train,
splitedData = data_split,
algo = paste0(algo,"_",engine))
models_list <- append(models_list, list(finalized[[2]]))
models_list
data(titanic_train, package = "titanic")
cleaned_data <- tibble::as_tibble(titanic_train) %>%
dplyr::select(-c(PassengerId, Name, Cabin, Ticket)) %>%
dplyr::mutate(across(where(is.character), factor)) %>%
dplyr::mutate(Survived = as.factor(Survived ))
rec <- recipes::recipe(Survived ~ ., data = cleaned_data) %>%
recipes::step_dummy(recipes::all_predictors(), -recipes::all_numeric())
rec_prep <- recipes::prep(rec)
cleaned_data <- recipes::bake(rec_prep, new_data = cleaned_data)
knitr::kable(head(cleaned_data, 10))
targetVar <- "Survived"
trainSetRatio <- "0.7"
split_tmp <- goophi::trainTestSplit(data = cleaned_data,
target = targetVar,
prop = trainSetRatio,
seed = 1234)
data_train <- split_tmp[[1]] # train data
data_test <- split_tmp[[2]] # test data
data_split <- split_tmp[[3]] # whole data with split information
DT::datatable(data_train, options = list(scrollX = TRUE))
formula <- paste0(targetVar, " ~ .") # user 입력 x (1에서 user가 targetVar를 입력했을 때 함께 생성)
imputation <- TRUE
normalization <- TRUE
pca <- FALSE
pcaThres <- "0.7"
imputationType = "mean"
normalizationType = "range"
rec <- goophi::prepForCV(data = data_train,
formula = formula,
imputationType = imputationType,
normalizationType = normalizationType,
pcaThres = pcaThres,
imputation = imputation,
normalization = normalization,
pca = pca,
seed = 1234)
formula <- paste0(targetVar, " ~ .") # user 입력 x (1에서 user가 targetVar를 입력했을 때 함께 생성)
imputation <- TRUE
normalization <- TRUE
pca <- FALSE
pcaThres <- "0.7"
imputationType = "mean"
normalizationType = "range"
# 모델 object를 저장할 빈 리스트를 생성합니다.
models_list <- list()
data("Boston")
require(MASS)
data("Boston")
attach(Boston)
View(Boston)
View(Boston)
str(Boston)
require(dplyr) # import for loading/preprocessing the sample data
require(MASS)
data("Boston")
attach(Boston)
library(goophi)
cleaned_data <- Boston %>%
as.factor(chas)
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas))
cleaned_data
str(cleaned_data)
rec <- recipes::recipe(crim ~ ., data = cleaned_data) %>%
recipes::step_naomit(recipes::all_nominal_predictors()) %>%
recipes::step_dummy(recipes::all_nominal_predictors())
rec_prep <- recipes::prep(rec)
rec_prep
cleaned_data <- recipes::bake(rec_prep, new_data = cleaned_data)
knitr::kable(head(cleaned_data, 10))
View(cleaned_data)
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas))
rec <- recipes::recipe(crim ~ ., data = cleaned_data) %>%
#recipes::step_naomit(recipes::all_nominal_predictors()) %>%
recipes::step_dummy(recipes::all_nominal_predictors())
rec_prep <- recipes::prep(rec)
cleaned_data <- recipes::bake(rec_prep, new_data = cleaned_data)
knitr::kable(head(cleaned_data, 10))
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas))
View(cleaned_data)
rec <- recipes::recipe(crim ~ ., data = cleaned_data) %>%
#recipes::step_naomit(recipes::all_nominal_predictors()) %>%
recipes::step_dummy(recipes::all_nominal_predictors())
cleaned_data <- recipes::bake(rec, new_data = cleaned_data)
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas))
rec <- recipes::recipe(crim ~ ., data = cleaned_data) %>%
#recipes::step_naomit(recipes::all_nominal_predictors()) %>%
recipes::step_dummy(recipes::all_nominal_predictors()) %>%
recipes::prep(rec)
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas))
rec <- recipes::recipe(crim ~ ., data = cleaned_data) %>%
recipes::step_dummy(recipes::all_nominal_predictors()) %>%
recipes::prep(rec)
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas))
knitr::kable(head(cleaned_data, 10))
require(dplyr)
library(goophi)
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas)) %>%
mutate(Pcrime  = ifelse(crim > median(crim), 1, 0) ) %>%
select(-c(crim))
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas)) %>%
mutate(Pcrime  = ifelse(crim > median(crim), 1, 0) ) %>%
select(-c(crim))
knitr::kable(head(cleaned_data, 10))
View(cleaned_data)
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas))
knitr::kable(head(cleaned_data, 10))
split_tmp <- goophi::trainTestSplit(data = cleaned_data, target = targetVar, prop = trainSetRatio)
View(cleaned_data)
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
library(goophi)
require(dplyr) # import for loading/preprocessing the sample data
require(MASS)
data("Boston")
attach(Boston)
library(goophi)
targetVar <- "crim"
trainSetRatio <- "0.7"
split_tmp <- goophi::trainTestSplit(data = cleaned_data, target = targetVar, prop = trainSetRatio)
targetVar <- "crim"
trainSetRatio <- "0.7"
dataSplit <- rsample::initial_split(data, strata = eval(parse(text = target)), prop = as.numeric(prop))
dataSplit <- rsample::initial_split(cleaned_data, strata = eval(parse(text = target)), prop = as.numeric(prop))
dataSplit <- rsample::initial_split(cleaned_data, strata = eval(parse(text = targetVar)), prop = as.numeric(prop))
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas)) %>%
mutate(crim = as.integer(crim*100))
knitr::kable(head(cleaned_data, 10))
targetVar <- "crim"
trainSetRatio <- "0.7"
dataSplit <- rsample::initial_split(cleaned_data, strata = eval(parse(text = targetVar)), prop = as.numeric(prop))
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas))
knitr::kable(head(cleaned_data, 10))
dataSplit <- rsample::initial_split(cleaned_data, strata = eval(parse(text = targetVar)), prop = as.numeric(trainSetRatio))
as.numeric(trainSetRatio)
targetVar
dataSplit <- rsample::initial_split(cleaned_data, strata = targetVar, prop = as.numeric(trainSetRatio))
dataSplit
dataSplit[[2]]
View(cleaned_data)
?all_if
?all_of
dataSplit <- rsample::initial_split(cleaned_data, strata = tidyselect::all_of(targetVar), prop = as.numeric(trainSetRatio))
train <- rsample::training(dataSplit)
test  <- rsample::testing(dataSplit)
show_engines(logistic_reg)
show_engines(logistic)
show_engines("logistic_reg")
?parsnip::logistic_reg
require(dplyr) # import for loading/preprocessing the sample data
require(MASS)
data("Boston")
attach(Boston)
library(goophi)
cleaned_data <- Boston %>%
mutate(chas = as.factor(chas))
knitr::kable(head(cleaned_data, 10))
targetVar <- "crim"
trainSetRatio <- "0.7"
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
split_tmp <- goophi::trainTestSplit(data = cleaned_data, target = targetVar, prop = trainSetRatio)
data_train <- split_tmp$train # train data
data_test <- split_tmp$test # test data
data_split <- split_tmp$dataSplit # whole data with split information
#
#
# dataSplit <- rsample::initial_split(cleaned_data, strata = eval(parse(text = targetVar)), prop = as.numeric(trainSetRatio))
# dataSplit <- rsample::initial_split(cleaned_data, strata = tidyselect::all_of(targetVar), prop = as.numeric(trainSetRatio))
# train <- rsample::training(dataSplit)
# test  <- rsample::testing(dataSplit)
#DT::datatable(data_train, options = list(scrollX = TRUE))
show_engines(logistic_reg)
show_engines("logistic_reg")
?logistic_reg
show_engines("rand_forest")
targetVar <- "crim"
trainSetRatio <- "0.7"
split_tmp <- goophi::trainTestSplit(data = cleaned_data, target = targetVar, prop = trainSetRatio)
data_train <- split_tmp$train # train data
data_test <- split_tmp$test # test data
data_split <- split_tmp$dataSplit # whole data with split information
DT::datatable(data_train, options = list(scrollX = TRUE))
formula <- paste0(targetVar, " ~ .") # user 입력 x (1에서 user가 targetVar를 입력했을 때 함께 생성)
imputation <- TRUE
normalization <- TRUE
pca <- FALSE
pcaThres <- "0.7"
imputationType = "mean" # 정리필요
normalizationType = "range" # 정리필요
rec <- goophi::prepForCV(data = data_train,
formula = formula,
imputationType = imputationType,
normalizationType = normalizationType,
pcaThres = pcaThres,
imputation = imputation,
normalization = normalization,
pca = pca)
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
rec <- goophi::prepForCV(data = data_train,
formula = formula,
imputationType = imputationType,
normalizationType = normalizationType,
pcaThres = pcaThres,
imputation = imputation,
normalization = normalization,
pca = pca)
rec
# 모델 object를 저장할 빈 리스트를 생성합니다.
models_list <- list()
mode <- "regression"
algo <- "LinearR"
engine <- "lm"
penaltyRangeMin = "0.1"
penaltyRangeMax = "20"
penaltyRangeLevels = "5"
mixtureRangeMin = "0.0"
mixtureRangeMax = "1.0"
mixtureRangeLevels = "5"
v <- "2"
metric <- "rmse"
if (algo == "LinearR") {
model <- goophi::linearRegression_phi(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
#################
#   penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
#   mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
#
#   parameterGrid <- dials::grid_regular(
#       dials::penalty(range = penaltyRange),
#       dials::mixture(range = mixtureRange),
#       levels = c(penalty = as.numeric(penaltyRangeLevels),
#                  mixture = as.numeric(mixtureRangeLevels)
#       )
#     )
#   ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
#
#   model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
#     parsnip::set_engine(engine = engine) %>%
#     parsnip::set_mode(mode = mode) %>%
#     translate()
#
#   tunedWorkflow <- workflows::workflow() %>%
#   workflows::add_recipe(rec) %>%
#   workflows::add_model(model)
#
#   result <- tune::tune_grid(tunedWorkflow,
#                             resamples = rsample::vfold_cv(data_train, v = 2),
#                             grid = parameterGrid) # warnings
#
#   #################
#
#   fit <- linear_reg(penalty = 1) %>%
#   set_engine("glmnet") %>%
#   fit(SalePrice ~ ., data = data_train)
#
# # predict at penalty = 1
#   predict(fit, data_train[1:3,])
####################
finalized <- goophi::fitBestModel(gridSearchResult = grid_search_result,
metric = metric,
model = model,
formula = formula,
trainingData = data_train,
splitedData = data_split,
algo = paste0(algo,"_",engine))
models_list <- append(models_list, list(finalized[[2]]))
}
if (algo == "LinearR") {
model <- goophi::linearRegression(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
#################
#   penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
#   mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
#
#   parameterGrid <- dials::grid_regular(
#       dials::penalty(range = penaltyRange),
#       dials::mixture(range = mixtureRange),
#       levels = c(penalty = as.numeric(penaltyRangeLevels),
#                  mixture = as.numeric(mixtureRangeLevels)
#       )
#     )
#   ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
#
#   model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
#     parsnip::set_engine(engine = engine) %>%
#     parsnip::set_mode(mode = mode) %>%
#     translate()
#
#   tunedWorkflow <- workflows::workflow() %>%
#   workflows::add_recipe(rec) %>%
#   workflows::add_model(model)
#
#   result <- tune::tune_grid(tunedWorkflow,
#                             resamples = rsample::vfold_cv(data_train, v = 2),
#                             grid = parameterGrid) # warnings
#
#   #################
#
#   fit <- linear_reg(penalty = 1) %>%
#   set_engine("glmnet") %>%
#   fit(SalePrice ~ ., data = data_train)
#
# # predict at penalty = 1
#   predict(fit, data_train[1:3,])
####################
finalized <- goophi::fitBestModel(gridSearchResult = grid_search_result,
metric = metric,
model = model,
formula = formula,
trainingData = data_train,
splitedData = data_split,
algo = paste0(algo,"_",engine))
models_list <- append(models_list, list(finalized[[2]]))
}
model <- goophi::linearRegression(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
model <- goophi::linearRegression(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
mode <- "regression"
algo <- "LinearR"
engine <- "glmnet"
penaltyRangeMin = "0.1"
penaltyRangeMax = "20"
penaltyRangeLevels = "5"
mixtureRangeMin = "0.0"
mixtureRangeMax = "1.0"
mixtureRangeLevels = "5"
v <- "2"
metric <- "rmse"
model <- goophi::linearRegression(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
mode <- "regression"
algo <- "LinearR"
engine <- "lm"
penaltyRangeMin = "0.1"
penaltyRangeMax = "20"
penaltyRangeLevels = "5"
mixtureRangeMin = "0.0"
mixtureRangeMax = "1.0"
mixtureRangeLevels = "5"
v <- "2"
metric <- "rmse"
model <- goophi::linearRegression(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
finalized <- goophi::fitBestModel(gridSearchResult = model,
metric = metric,
model = model,
formula = formula,
trainingData = data_train,
splitedData = data_split,
algo = paste0(algo,"_",engine))
model
grid_search_result <- goophi::linearRegression(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
finalized <- goophi::fitBestModel(gridSearchResult = grid_search_result,
metric = metric,
model = model,
formula = formula,
trainingData = data_train,
splitedData = data_split,
algo = paste0(algo,"_",engine))
grid_search_result[[2]]
tune::select_best(grid_search_result[[2]], "rmse")
tune::select_best(grid_search_result[[2]], "rmse")[1]
tune::select_best(grid_search_result[[2]], "rmse")[[1]]
mode <- "regression"
algo <- "LinearR"
engine <- "glmnet"
penaltyRangeMin = "0.1"
penaltyRangeMax = "20"
penaltyRangeLevels = "5"
mixtureRangeMin = "0.0"
mixtureRangeMax = "1.0"
mixtureRangeLevels = "5"
v <- "2"
metric <- "rmse"
grid_search_result <- goophi::linearRegression(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
