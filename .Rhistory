cleaned_data<- iris
rec <- recipes::recipe(SalePrice ~ ., data = cleaned_data) %>%
recipes::step_naomit(recipes::all_nominal_predictors()) %>%
recipes::step_dummy(recipes::all_nominal_predictors())
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
library(rlang, lib.loc = "C:/Program Files/R/R-4.2.0/library")
library(rlang)
library(rlang, lib.loc = "C:/Program Files/R/R-4.2.0/library")
install.packages("rlang")
install.packages("rlang")
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
# 함수 추가 시 roxygen 주석을 포함시켜 작성하고, 아래 코드로 주석을 .Rd 파일로 전환 및 NAMESPACE에 추가
devtools::document()
library(goophi)
data(iris)
require(dplyr) # import for loading/preprocessing the sample data
library(goophi)
data(iris)
# cleaned_data <- readr::read_csv(
#     "../data/housePrice.csv") %>%
#   dplyr::select(c("SalePrice", "MSSubClass", "LotArea", "OverallQual", "OverallCond", "Street"))
cleaned_data <- iris
rec <- recipes::recipe(SalePrice ~ ., data = cleaned_data) %>%
recipes::step_naomit(recipes::all_nominal_predictors()) %>%
recipes::step_dummy(recipes::all_nominal_predictors())
cleaned_data
# cleaned_data <- readr::read_csv(
#     "../data/housePrice.csv") %>%
#   dplyr::select(c("SalePrice", "MSSubClass", "LotArea", "OverallQual", "OverallCond", "Street"))
cleaned_data <- iris
rec <- recipes::recipe(Sepal.Length ~ ., data = cleaned_data) %>%
recipes::step_naomit(recipes::all_nominal_predictors()) %>%
recipes::step_dummy(recipes::all_nominal_predictors())
rec_prep <- recipes::prep(rec)
cleaned_data <- recipes::bake(rec_prep, new_data = cleaned_data)
knitr::kable(head(cleaned_data, 10))
# targetVar <- "SalePrice"
targetVar <- "Sepal.Length"
trainSetRatio <- "0.7"
split_tmp <- goophi::trainTestSplit(data = cleaned_data, target = targetVar, prop = trainSetRatio)
data_train <- split_tmp$train # train data
data_test <- split_tmp$test # test data
data_split <- split_tmp$dataSplit # whole data with split information
#DT::datatable(data_train, options = list(scrollX = TRUE))
formula <- paste0(targetVar, " ~ .") # user 입력 x (1에서 user가 targetVar를 입력했을 때 함께 생성)
imputation <- TRUE
# normalization <- TRUE
normalization <- FALSE
pca <- FALSE
pcaThres <- "0.7"
imputationType = "mean" # 정리필요
normalizationType = "range" # 정리필요
rec <- goophi::prepForCV(data = data_train,
formula = formula,
imputationType = imputationType,
normalizationType = normalizationType,
pcaThres = pcaThres,
imputation = imputation,
normalization = normalization,
pca = pca)
# 모델 object를 저장할 빈 리스트를 생성합니다.
models_list <- list()
mode <- "regression"
algo <- "LinearR"
engine <- "glmnet"
penaltyRangeMin = "0.1"
penaltyRangeMax = "20"
penaltyRangeLevels = "5"
mixtureRangeMin = "0.0"
mixtureRangeMax = "1.0"
mixtureRangeLevels = "5"
v <- "2"
metric <- "rmse"
if (algo == "LinearR") {
model <- goophi::linearRegression_phi(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
#################
penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
parameterGrid <- dials::grid_regular(
dials::penalty(range = penaltyRange),
dials::mixture(range = mixtureRange),
levels = c(penalty = as.numeric(penaltyRangeLevels),
mixture = as.numeric(mixtureRangeLevels)
)
)
ctrl <- control_grid(save_pred = TRUE, verbose = TRUE)
model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
parsnip::set_engine(engine = engine) %>%
parsnip::set_mode(mode = mode) %>%
translate()
tunedWorkflow <- workflows::workflow() %>%
workflows::add_recipe(rec) %>%
workflows::add_model(model)
result <- tune::tune_grid(tunedWorkflow,
resamples = rsample::vfold_cv(data_train, v = 2),
grid = parameterGrid,
metrics = yardstick::metric_set(rmse),
control = ctrl) # warnings
#################
fit <- linear_reg(penalty = 1) %>%
set_engine("glmnet") %>%
fit(SalePrice ~ ., data = data_train)
# predict at penalty = 1
predict(fit, data_train[1:3,])
####################
finalized <- goophi::fitBestModel(gridSearchResult = grid_search_result,
metric = metric,
model = model,
formula = formula,
trainingData = data_train,
splitedData = data_split,
algo = paste0(algo,"_",engine))
models_list <- append(models_list, list(finalized[[2]]))
}
penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
parameterGrid <- dials::grid_regular(
dials::penalty(range = penaltyRange),
dials::mixture(range = mixtureRange),
levels = c(penalty = as.numeric(penaltyRangeLevels),
mixture = as.numeric(mixtureRangeLevels)
)
)
ctrl <- control_grid(save_pred = TRUE, verbose = TRUE)
?control_grid
penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
parameterGrid <- dials::grid_regular(
dials::penalty(range = penaltyRange),
dials::mixture(range = mixtureRange),
levels = c(penalty = as.numeric(penaltyRangeLevels),
mixture = as.numeric(mixtureRangeLevels)
)
)
ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
parsnip::set_engine(engine = engine) %>%
parsnip::set_mode(mode = mode) %>%
translate()
tunedWorkflow <- workflows::workflow() %>%
workflows::add_recipe(rec) %>%
workflows::add_model(model)
result <- tune::tune_grid(tunedWorkflow,
resamples = rsample::vfold_cv(data_train, v = 2),
grid = parameterGrid,
metrics = yardstick::metric_set(rmse),
control = ctrl) # warnings
penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
parameterGrid <- dials::grid_regular(
dials::penalty(range = penaltyRange),
dials::mixture(range = mixtureRange),
levels = c(penalty = as.numeric(penaltyRangeLevels),
mixture = as.numeric(mixtureRangeLevels)
)
)
ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
parsnip::set_engine(engine = engine) %>%
parsnip::set_mode(mode = mode) %>%
translate()
tunedWorkflow <- workflows::workflow() %>%
workflows::add_recipe(rec) %>%
workflows::add_model(model)
result <- tune::tune_grid(tunedWorkflow,
resamples = rsample::vfold_cv(data_train, v = 2),
grid = parameterGrid,
metrics = yardstick::metric_set(mae),
control = ctrl) # warnings
penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
parameterGrid <- dials::grid_regular(
dials::penalty(range = penaltyRange),
dials::mixture(range = mixtureRange),
levels = c(penalty = as.numeric(penaltyRangeLevels),
mixture = as.numeric(mixtureRangeLevels)
)
)
ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
parsnip::set_engine(engine = engine) %>%
parsnip::set_mode(mode = mode) %>%
translate()
tunedWorkflow <- workflows::workflow() %>%
workflows::add_recipe(rec) %>%
workflows::add_model(model)
result <- tune::tune_grid(tunedWorkflow,
resamples = rsample::vfold_cv(data_train, v = 2),
grid = parameterGrid
control = ctrl) # warnings
penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
parameterGrid <- dials::grid_regular(
dials::penalty(range = penaltyRange),
dials::mixture(range = mixtureRange),
levels = c(penalty = as.numeric(penaltyRangeLevels),
mixture = as.numeric(mixtureRangeLevels)
)
)
ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
parsnip::set_engine(engine = engine) %>%
parsnip::set_mode(mode = mode) %>%
translate()
tunedWorkflow <- workflows::workflow() %>%
workflows::add_recipe(rec) %>%
workflows::add_model(model)
result <- tune::tune_grid(tunedWorkflow,
resamples = rsample::vfold_cv(data_train, v = 2),
grid = parameterGrid,
control = ctrl) # warnings
penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
parameterGrid <- dials::grid_regular(
dials::penalty(range = penaltyRange),
dials::mixture(range = mixtureRange),
levels = c(penalty = as.numeric(penaltyRangeLevels),
mixture = as.numeric(mixtureRangeLevels)
)
)
ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
parsnip::set_engine(engine = engine) %>%
parsnip::set_mode(mode = mode) %>%
translate()
tunedWorkflow <- workflows::workflow() %>%
workflows::add_recipe(rec) %>%
workflows::add_model(model)
result <- tune::tune_grid(tunedWorkflow,
resamples = rsample::vfold_cv(data_train, v = 2),
grid = parameterGrid) # warnings
penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
parameterGrid <- dials::grid_regular(
dials::penalty(range = penaltyRange),
dials::mixture(range = mixtureRange),
levels = c(penalty = as.numeric(penaltyRangeLevels),
mixture = as.numeric(mixtureRangeLevels)
)
)
ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
parsnip::set_engine(engine = engine)
tunedWorkflow <- workflows::workflow() %>%
workflows::add_recipe(rec) %>%
workflows::add_model(model)
result <- tune::tune_grid(tunedWorkflow,
resamples = rsample::vfold_cv(data_train, v = 2),
grid = parameterGrid) # warnings
set.seed(930093)
cv_splits <- rsample::vfold_cv(data_train)
model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
parsnip::set_engine(engine = engine) %>%
parsnip::set_mode(mode = mode) %>%
translate()
rec <- recipe(SalePrice ~ ., data = data_train)
wfl <- workflow() %>%
add_recipe(rec) %>%
add_model(model)
glmn_set <- parameters(penalty(range = c(-5,1), trans = log10_trans()),
mixture())
glmn_grid <-
grid_regular(glmn_set, levels = c(7, 5))
ctrl <- control_grid(save_pred = TRUE, verbose = TRUE)
model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
parsnip::set_engine(engine = engine) %>%
parsnip::set_mode(mode = mode) %>%
translate()
rec <- recipe(SalePrice ~ ., data = data_train)
wfl <- workflow() %>%
add_recipe(rec) %>%
add_model(model)
glmn_set <- parameters(penalty(range = c(-5,1), trans = log10_trans()),
mixture())
glmn_grid <-
grid_regular(glmn_set, levels = c(7, 5))
ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
set.seed(930093)
cv_splits <- rsample::vfold_cv(data_train)
model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
parsnip::set_engine(engine = engine) %>%
parsnip::set_mode(mode = mode) %>%
translate()
rec <- recipe(SalePrice ~ ., data = data_train)
?recipe
rec <- recipes::recipe(SalePrice ~ ., data = data_train)
rec <- recipes::recipe(formula = SalePrice ~ ., data = data_train)
rec <- recipes::recipe(formula = "SalePrice ~ .", data = data_train)
rec <- recipes::recipe("SalePrice ~ .", data = data_train)
data_train
rec <- recipes::recipe("SalePrice ~ .", data = data_train)
View(data_train)
rec <- recipes::recipe("Sepal.Width ~ .", data = data_train)
rec <- recipes::recipe(Sepal.Width ~ ., data = data_train)
wfl <- workflow() %>%
add_recipe(rec) %>%
add_model(model)
wfl <- workflows::workflow() %>%
workflows::add_recipe(rec) %>%
workflows::add_model(model)
glmn_set <- parameters(penalty(range = c(-5,1), trans = log10_trans()),
mixture())
glmn_set <- dials::parameters(penalty(range = c(-5,1), trans = log10_trans()),
mixture())
glmn_set <- dials::parameters(dials::penalty(range = c(-5,1), trans = log10_trans()),
dials::mixture())
glmn_set <- dials::parameters(dials::penalty(range = c(-5,1)),
dials::mixture())
glmn_grid <-
grid_regular(glmn_set, levels = c(7, 5))
glmn_grid <-
dials::grid_regular(glmn_set, levels = c(7, 5))
ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
glmn_tune <-
tune_grid(wfl,
resamples = cv_splits,
grid = glmn_grid,
metrics = metric_set(roc_auc),
control = ctrl)
glmn_tune <-
tune::tune_grid(wfl,
resamples = cv_splits,
grid = glmn_grid,
metrics = metric_set(roc_auc),
control = ctrl)
glmn_tune <-
tune::tune_grid(wfl,
resamples = cv_splits,
grid = glmn_grid,
metrics = yardstik::metric_set(roc_auc),
control = ctrl)
?metric_set
glmn_tune <-
tune::tune_grid(wfl,
resamples = cv_splits,
grid = glmn_grid,
metrics = yardstick::metric_set(roc_auc),
control = ctrl)
glmn_tune <-
tune::tune_grid(wfl,
resamples = cv_splits,
grid = glmn_grid,
metrics = yardstick::metric_set(mae),
control = ctrl)
glmn_tune <-
tune::tune_grid(wfl,
resamples = cv_splits,
grid = glmn_grid,
control = ctrl)
mode <- "regression"
algo <- "LinearR"
engine <- "stats"
penaltyRangeMin = "0.1"
penaltyRangeMax = "20"
penaltyRangeLevels = "5"
mixtureRangeMin = "0.0"
mixtureRangeMax = "1.0"
mixtureRangeLevels = "5"
v <- "2"
metric <- "rmse"
if (algo == "LinearR") {
model <- goophi::linearRegression_phi(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
#################
#   penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
#   mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
#
#   parameterGrid <- dials::grid_regular(
#       dials::penalty(range = penaltyRange),
#       dials::mixture(range = mixtureRange),
#       levels = c(penalty = as.numeric(penaltyRangeLevels),
#                  mixture = as.numeric(mixtureRangeLevels)
#       )
#     )
#   ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
#
#   model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
#     parsnip::set_engine(engine = engine) %>%
#     parsnip::set_mode(mode = mode) %>%
#     translate()
#
#   tunedWorkflow <- workflows::workflow() %>%
#   workflows::add_recipe(rec) %>%
#   workflows::add_model(model)
#
#   result <- tune::tune_grid(tunedWorkflow,
#                             resamples = rsample::vfold_cv(data_train, v = 2),
#                             grid = parameterGrid) # warnings
#
#   #################
#
#   fit <- linear_reg(penalty = 1) %>%
#   set_engine("glmnet") %>%
#   fit(SalePrice ~ ., data = data_train)
#
# # predict at penalty = 1
#   predict(fit, data_train[1:3,])
####################
finalized <- goophi::fitBestModel(gridSearchResult = grid_search_result,
metric = metric,
model = model,
formula = formula,
trainingData = data_train,
splitedData = data_split,
algo = paste0(algo,"_",engine))
models_list <- append(models_list, list(finalized[[2]]))
}
show_engines('linear_reg')
mode <- "regression"
algo <- "LinearR"
engine <- "lm"
penaltyRangeMin = "0.1"
penaltyRangeMax = "20"
penaltyRangeLevels = "5"
mixtureRangeMin = "0.0"
mixtureRangeMax = "1.0"
mixtureRangeLevels = "5"
v <- "2"
metric <- "rmse"
if (algo == "LinearR") {
model <- goophi::linearRegression_phi(engine = engine,
mode = mode,
data = data_train,
rec = rec,
v = 2,
penaltyRangeMin = penaltyRangeMin,
penaltyRangeMax = penaltyRangeMax,
penaltyRangeLevels = penaltyRangeLevels,
mixtureRangeMin = mixtureRangeMin,
mixtureRangeMax = mixtureRangeMax,
mixtureRangeLevels = mixtureRangeLevels
)
#################
#   penaltyRange <- c(as.numeric(penaltyRangeMin), as.numeric(penaltyRangeMax))
#   mixtureRange <- c(as.numeric(mixtureRangeMin), as.numeric(mixtureRangeMax))
#
#   parameterGrid <- dials::grid_regular(
#       dials::penalty(range = penaltyRange),
#       dials::mixture(range = mixtureRange),
#       levels = c(penalty = as.numeric(penaltyRangeLevels),
#                  mixture = as.numeric(mixtureRangeLevels)
#       )
#     )
#   ctrl <- tune::control_grid(save_pred = TRUE, verbose = TRUE)
#
#   model <- parsnip::linear_reg(penalty = tune(), mixture = tune()) %>%
#     parsnip::set_engine(engine = engine) %>%
#     parsnip::set_mode(mode = mode) %>%
#     translate()
#
#   tunedWorkflow <- workflows::workflow() %>%
#   workflows::add_recipe(rec) %>%
#   workflows::add_model(model)
#
#   result <- tune::tune_grid(tunedWorkflow,
#                             resamples = rsample::vfold_cv(data_train, v = 2),
#                             grid = parameterGrid) # warnings
#
#   #################
#
#   fit <- linear_reg(penalty = 1) %>%
#   set_engine("glmnet") %>%
#   fit(SalePrice ~ ., data = data_train)
#
# # predict at penalty = 1
#   predict(fit, data_train[1:3,])
####################
finalized <- goophi::fitBestModel(gridSearchResult = grid_search_result,
metric = metric,
model = model,
formula = formula,
trainingData = data_train,
splitedData = data_split,
algo = paste0(algo,"_",engine))
models_list <- append(models_list, list(finalized[[2]]))
}
data_train
require(dplyr)
library(tidymodels)
library(vip)
library(RColorBrewer)
library(cowplot)
library(data.table)
library(DT)
library(goophi)
